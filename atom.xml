<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sttot Stack]]></title>
  <link href="https://gk0wk.github.io/atom.xml" rel="self"/>
  <link href="https://gk0wk.github.io/"/>
  <updated>2019-11-13T02:31:54+08:00</updated>
  <id>https://gk0wk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[AppleScript样例]]></title>
    <link href="https://gk0wk.github.io/15735830719694.html"/>
    <updated>2019-11-13T02:24:31+08:00</updated>
    <id>https://gk0wk.github.io/15735830719694.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">使用 mac 的邮件系统</h2>

<pre><code class="language-applescript">--Variables
set recipientName to &quot; 小红&quot;
set recipientAddress to &quot;aliyunzixun@xxx.com&quot;
set theSubject to &quot;AppleScript Automated Email&quot;
set theContent to &quot;This email was created and sent using AppleScript!&quot;
--Mail Tell Block
tell application &quot;Mail&quot;
--Create the message
set theMessage to make new outgoing message with properties {subject:theSubject, content:theContent, visible:true}
--Set a recipient
tell theMessage
    make new to recipient with properties {name:recipientName, address:recipientAddress}
    --Send the Message
    send
end tell
end tell
</code></pre>

<h2 id="toc_1">让浏览器打开网页</h2>

<pre><code class="language-applescript">set urlMyBlog to &quot;https://blog.csdn.net/sodaslay&quot;
set urlChinaSearch to &quot;http://www.chinaso.com&quot;
set urlBiying to &quot;https://cn.bing.com&quot;

--使用Chrome浏览器
tell application &quot;Google Chrome&quot;
--新建一个chrome窗口
set window1 to make new window
tell window1
    --当前标签页加载必应,就是不用百度哈哈
    set currTab to active tab of window1
    set URL of currTab to urlBiying
    --打开csdn博客,搜索
    make new tab with properties {URL:urlMyBlog}
    make new tab with properties {URL:urlChinaSearch}
    --将焦点由最后一个打开的标签页还给首个标签页
    set active tab index of window1 to 1
end tell
end tell
</code></pre>

<h2 id="toc_2">让你的电脑说话</h2>

<pre><code class="language-applescript">-- You can use any of the voices from the System Voice pop-up on the Text to Speech tab in the Speech preferences pane.
-- Default Value:
-- The current System Voice (set in the Speech panel in System Preferences.

tell current application
say &quot;My name is LiMei. Nice to meet you. How are you?&quot; using &quot;Veena&quot;
say &quot;Fine, thanks. And you?&quot; using &quot;Victoria&quot;
say &quot;滚&quot;
say &quot;我跟你说&quot; using &quot;Sin-Ji&quot;
end tell

beep
</code></pre>

<h2 id="toc_3">调用 mac 的通知中心</h2>

<blockquote>
<p>crontab + AppleScript + 通知中心 可以做很多定制的提醒工具</p>
</blockquote>

<pre><code class="language-applescript">display notification &quot;message&quot; with title &quot;title&quot; subtitle &quot;subtitle&quot;

display notification &quot;message&quot; sound name &quot;Bottle.aiff&quot;
-- 声音文件都在 ~/Library/Sounds 和 /System/Library/Sounds 下面
</code></pre>

<h2 id="toc_4">清理废纸篓</h2>

<pre><code class="language-applescript">tell application &quot;Finder&quot;
empty the trash
beep
-- 打开启动磁盘
open the startup disk
end tell
</code></pre>

<h2 id="toc_5">模拟键盘按键消息</h2>

<pre><code class="language-applescript">launch application &quot;System Events&quot;
launch application &quot;TextMate&quot;
tell application &quot;System Events&quot;
set frontmost of process &quot;TextMate&quot; to true
keystroke &quot;input string from applescript&quot;
keystroke &quot;a&quot; using command down
keystroke &quot;c&quot; using command down
keystroke &quot;a&quot; using command down
key code 124 using command down
keystroke &quot;
&quot;
keystroke &quot;v&quot; using command down
end tell
</code></pre>

<p>&lt;&lt;&lt;<br/>
其中 using command 可以使用组合，例如：key code 53 using {command down, option down}<br/>
其中的 key code 对照表如下<br/>
&lt;&lt;&lt;</p>

<pre><code class="language-applescript">apple key code list:

0 0x00 ANSI_A
1 0x01 ANSI_S
2 0x02 ANSI_D
3 0x03 ANSI_F
4 0x04 ANSI_H
5 0x05 ANSI_G
6 0x06 ANSI_Z
7 0x07 ANSI_X
8 0x08 ANSI_C
9 0x09 ANSI_V
10 0x0A ISO_Section
11 0x0B ANSI_B
12 0x0C ANSI_Q
13 0x0D ANSI_W
14 0x0E ANSI_E
15 0x0F ANSI_R
16 0x10 ANSI_Y
17 0x11 ANSI_T
18 0x12 ANSI_1
19 0x13 ANSI_2
20 0x14 ANSI_3
21 0x15 ANSI_4
22 0x16 ANSI_6
23 0x17 ANSI_5
24 0x18 ANSI_Equal
25 0x19 ANSI_9
26 0x1A ANSI_7
27 0x1B ANSI_Minus
28 0x1C ANSI_8
29 0x1D ANSI_0
30 0x1E ANSI_RightBracket
31 0x1F ANSI_O
32 0x20 ANSI_U
33 0x21 ANSI_LeftBracket
34 0x22 ANSI_I
35 0x23 ANSI_P
36 0x24 Return
37 0x25 ANSI_L
38 0x26 ANSI_J
39 0x27 ANSI_Quote
40 0x28 ANSI_K
41 0x29 ANSI_Semicolon
42 0x2A ANSI_Backslash
43 0x2B ANSI_Comma
44 0x2C ANSI_Slash
45 0x2D ANSI_N
46 0x2E ANSI_M
47 0x2F ANSI_Period
48 0x30 Tab
49 0x31 Space
50 0x32 ANSI_Grave
51 0x33 Delete
53 0x35 Escape
55 0x37 Command
56 0x38 Shift
57 0x39 CapsLock
58 0x3A Option
59 0x3B Control
60 0x3C RightShift
61 0x3D RightOption
62 0x3E RightControl
63 0x3F Function
64 0x40 F17
65 0x41 ANSI_KeypadDecimal
67 0x43 ANSI_KeypadMultiply
69 0x45 ANSI_KeypadPlus
71 0x47 ANSI_KeypadClear
72 0x48 VolumeUp
73 0x49 VolumeDown
74 0x4A Mute
75 0x4B ANSI_KeypadDivide
76 0x4C ANSI_KeypadEnter
78 0x4E ANSI_KeypadMinus
79 0x4F F18
80 0x50 F19
81 0x51 ANSI_KeypadEquals
82 0x52 ANSI_Keypad0
83 0x53 ANSI_Keypad1
84 0x54 ANSI_Keypad2
85 0x55 ANSI_Keypad3
86 0x56 ANSI_Keypad4
87 0x57 ANSI_Keypad5
88 0x58 ANSI_Keypad6
89 0x59 ANSI_Keypad7
90 0x5A F20
91 0x5B ANSI_Keypad8
92 0x5C ANSI_Keypad9
93 0x5D JIS_Yen
94 0x5E JIS_Underscore
95 0x5F JIS_KeypadComma
96 0x60 F5
97 0x61 F6
98 0x62 F7
99 0x63 F3
100 0x64 F8
101 0x65 F9
102 0x66 JIS_Eisu
103 0x67 F11
104 0x68 JIS_Kana
105 0x69 F13
106 0x6A F16
107 0x6B F14
109 0x6D F10
111 0x6F F12
113 0x71 F15
114 0x72 Help
115 0x73 Home
116 0x74 PageUp
117 0x75 ForwardDelete
118 0x76 F4
119 0x77 End
120 0x78 F2
121 0x79 PageDown
122 0x7A F1
123 0x7B LeftArrow
124 0x7C RightArrow
125 0x7D DownArrow
126 0x7E UpArrow
</code></pre>

<h2 id="toc_6">切换程序前台、设置焦点窗口</h2>

<pre><code class="language-applescript">-- 前提是当前 iTerm app 中打开了两个窗口，其中有个窗口名字叫 &quot;2. bash&quot; 并且该窗口中第一个 tab 中含有三个 session，本脚本的作用是让 &quot;2. bash&quot; 窗口中第一个 tab 中的第三个 session 变为焦点。
tell the application &quot;iTerm&quot;
activate

set theWindow to the first item of ¬
    (get the windows whose name is &quot;2. bash&quot;)
if index of theWindow is not 1 then
    set index of theWindow to 1

    set visible of theWindow to false
    set visible of theWindow to true
end if

tell theWindow
    set theTab to the first item of theWindow&#39;s tabs

    select theTab

    select the third session of theTab
end tell
end tell
</code></pre>

<pre><code class="language-applescript">-- 下面是上面的逻辑的另一种实现
tell the application &quot;iTerm&quot;
activate

set theWindow to the first item of ¬
    (get the windows whose name is &quot;2. bash&quot;)
if the index of theWindow is not 1 then
    set the index of theWindow to 2
    tell application &quot;System Events&quot; to ¬
        tell application process &quot;iTerm2&quot; to ¬
            keystroke &quot;`&quot; using command down
end if
end tell
</code></pre>

<h2 id="toc_7">粘贴板操作</h2>

<pre><code class="language-applescript">set the clipboard to &quot;Add this sentence at the end.&quot;
tell application &quot;TextEdit&quot;
activate --make sure TextEdit is running
make new paragraph at end of document 1 with data (return &amp; (the clipboard))
end tell
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AppleScript一些默认指令]]></title>
    <link href="https://gk0wk.github.io/15735830354689.html"/>
    <updated>2019-11-13T02:23:55+08:00</updated>
    <id>https://gk0wk.github.io/15735830354689.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">beep</h2>

<pre><code class="language-applescript">beep 发声次数
</code></pre>

<p>让 Mac 系统发出咚的声音，发声次数决定了咚出现的次数，例如 <code>beep 2</code> 那么 Mac 会咚两次。发声次数缺省为 1。</p>

<h2 id="toc_1">say</h2>

<p>语音转文字并输出</p>

<pre><code class="language-applescript">say &quot;说话的内容&quot; (using &quot;指定人的嗓音&quot;)
</code></pre>

<hr/>

<h2 id="toc_2">消息对话框 dialog</h2>

<p>使用<code>display dialog</code>弹出一个消息对话框：</p>

<pre><code class="language-applescript">display dialog &quot;消息文字&quot; (buttons {&quot;按钮1&quot;, &quot;按钮2&quot;, ...} (default button &quot;按钮名&quot;))
</code></pre>

<p>括号内为可省略部分。默认情况下按钮列表为 <code>取消</code> 和 <code>好</code> ，默认按钮为 <code>好</code>。</p>

<p>对话框关闭后，该行脚本返回一个Record，可以用 <strong>result</strong> 变量来获取，也可以用 <code>set xxx to dispkay ...</code> 来接。</p>

<p>在没有文本输入的对话框中，Record内容为：</p>

<pre><code class="language-applescript">{button returned: [按钮文字]}
</code></pre>
<br/>
<p>添加一个<code>default answer</code>让对话框具有文本输入框，如：</p>

<pre><code class="language-applescript">display dialog &quot;emmm&quot; defalut answer &quot;&quot; -- 字符串可留空
</code></pre>

<p>返回的Record内容为：</p>

<pre><code class="language-applescript">{button returned: [按钮文字], text returned: [输入的字符串]}
</code></pre>
<br/>
<h2 id="toc_3">警告对话框 alert</h2>

<p>使用<code>display alert</code>弹出一个消息对话框：</p>

<pre><code class="language-applescript">display alert &quot;标题&quot; (message &quot;内容&quot;) (buttons {&quot;按钮1&quot;, &quot;按钮2&quot;, ...} (default button &quot;按钮名&quot;)) (as warning)
</code></pre>
<br/>
<h2 id="toc_4">列表选择对话框</h2>

<pre><code class="language-applescript">choose from list {&quot;选项1&quot;, &quot;选项2&quot;, &quot;选项3&quot;} with title &quot;选择框&quot; with prompt &quot;请选择选项&quot;
</code></pre>

<p>参数：</p>

<ul>
<li>  <strong>title</strong> 紧跟 text，指定对话框的标题</li>
<li>  <strong>prompt</strong> 紧跟 text，指定提示信息</li>
<li>  <strong>default items</strong> 紧跟 list，指定默认选择的项目</li>
<li>  <strong>empty selection allowed</strong> 后紧跟 true 表示允许不选</li>
<li>  <strong>multiple selections allowed</strong> 后紧跟 true 表示允许多选</li>
</ul>
<br/>
<h2 id="toc_5">文件选择对话框</h2>

<pre><code class="language-applescript">-- 选取文件名称Choose File Name
choose file name with prompt &quot;指定提示信息&quot;

-- 选取文件夹Choose Folder
choose folder with prompt &quot;指定提示信息&quot; default location file &quot;Macintosh HD:Users&quot; with invisibles, multiple selections allowed and showing package contents

-- 选取文件Choose File
choose file of type {&quot;txt&quot;}
</code></pre>

<hr/>

<h2 id="toc_6">文件读写</h2>

<p>文件读取用 read，允许直接读取，但是写入文件之前必须先打开文件；</p>

<p>打开文件是 <code>open for access FileName</code></p>

<p>写入文件用 <code>write...to</code> 语句；</p>

<p>最后记得关闭文件 <code>close access filePoint</code></p>

<p>例子：</p>

<pre><code class="language-applescript">set myFile to alias &quot;Macintosh HD:Users:xiaxuqiang:Desktop:example.txt&quot;
read myFile
set aFile to alias &quot;Macintosh HD:Users:xiaxuqiang:Desktop:example.txt&quot;
set fp to open for access aFile with write permission
write &quot;AppleScript写入文本&quot; to fp
close access fp


--在桌面上创建一个文件,内部包含一个txt文件,并向txt内插入文件
on createMyTxt()
    tell application &quot;Finder&quot;
        make new folder at desktop with properties {name:&quot;star&quot;}
        make new file at folder &quot;star&quot; of desktop with properties {name:&quot;star.txt&quot;}
    end tell
end createMyTxt

--向txt文件内写入内容
on writeTextToFile()
    set txtFile to alias &quot;Macintosh HD:Users:xiaxuqiang:Desktop:star:star.txt&quot;
    set fp to open for access txtFile with write permission
    write &quot;你好,这是一个txt文件&quot; to fp as «class utf8»
    close access fp
end writeTextToFile

createMyTxt()

writeTextToFile()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tell 结构]]></title>
    <link href="https://gk0wk.github.io/15735830027400.html"/>
    <updated>2019-11-13T02:23:22+08:00</updated>
    <id>https://gk0wk.github.io/15735830027400.html</id>
    <content type="html"><![CDATA[
<p>之前讲过，我们执行命令、访问对象，都需要有所面向，需要确定是让哪一个程序去执行命令、操作哪一个程序的对象。不同的应用程序所支持的命令和类不同，需要查看<a href="%E4%BD%BF%E7%94%A8%20Script%20Editor.app">字典</a>。</p>

<span id="more"></span><!-- more -->

<p>脚本执行初始，我们所做的工作都是交给执行脚本的程序(比如 Script Editor.app)来做的，事实上，内置的变量、命令都是执行解析程序所拥有和执行的。</p>

<p>我们需要用 tell 模块将特定的任务交付给 Mac 中特定的程序，去访问他们的对象、执行他们的命令。</p>

<p>tell 模块的语法为：</p>

<pre><code class="language-text">tell application &quot;[应用程序名称]&quot;
    ...
end tell
</code></pre>

<p>注：tell结构支持嵌套。</p>

<p>例如我们想让 Finder 程序清空垃圾篓然后打开磁盘，可以这样写：</p>

<pre><code class="language-text">tell application &quot;Finder&quot;
    empty the trash
    beep
    open the startup disk
end tell
</code></pre>

<p>可以发现 <code>beep</code> 命令还是可以用的，无论tell了什么程序，脚本执行程序的功能和对象都可用；实际上，整个脚本都默认包含在</p>

<pre><code class="language-applescript">tell current application
    ...
end tell
</code></pre>

<p>这个结构中，<code>say</code>、<code>beep</code>、<code>display</code>等指令一只可用。</p>

<p>不过，<code>current application</code>是个特例，在其他嵌套tell结构中，只允许使用当前tell层应用所拥有的对象和指令，例如以下脚本会报错：</p>

<pre><code class="language-applescript">tell application &quot;Finder&quot;
    tell application &quot;OmniFocus&quot;
        open startup disk -- no such startup disk
    end tell
end tell
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Record 记录]]></title>
    <link href="https://gk0wk.github.io/15735829601096.html"/>
    <updated>2019-11-13T02:22:40+08:00</updated>
    <id>https://gk0wk.github.io/15735829601096.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">形式</h2>

<p>Record 的格式：</p>

<pre><code class="language-applescript">{name1: value1, name2: value2, name3: value3}
</code></pre>

<span id="more"></span><!-- more -->

<p>其中 name 相当于字典中的 key，value 相当于字典中的 value。一对 <code>name: value</code> 成为一个<code>属性(Property)</code></p>
<br/>
<h2 id="toc_1">赋值</h2>

<p>使用 <code>set to</code> 语句赋值：</p>

<pre><code class="language-applescript">set aRecord to {name1:100, name2:&quot;This is a record&quot;}
</code></pre>
<br/>
<h2 id="toc_2">获取属性/修改属性</h2>

<p><strong>记录中的单元叫做<code>属性（property）</code>，不是<code>元素（item）</code>。不能通过 <code>item</code> 来取出数据。</strong></p>

<p>可以通过 <code>name</code> 获取 <code>record</code> 中对应的 <code>value</code>：</p>

<pre><code class="language-applescript">set tempValOfName to the name1 of aRecord
</code></pre>
<br/>
<h2 id="toc_3">获取 Record 的 name/value 对数目</h2>

<p>用 <code>(the) count of</code> 获取 record 中的属性数目：</p>

<pre><code class="language-applescriptq">set numberOfProperties to the count of aRecord
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[List 列表]]></title>
    <link href="https://gk0wk.github.io/15735828924204.html"/>
    <updated>2019-11-13T02:21:32+08:00</updated>
    <id>https://gk0wk.github.io/15735828924204.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">形式</h2>

<p>以大括号括起来，逗号分割，元素的类型无限制。如：</p>

<pre><code class="language-applescript">{&quot;hello&quot;, 123, &quot;world&quot;}
</code></pre>

<span id="more"></span><!-- more -->
<br/>
<h2 id="toc_1">赋值</h2>

<p>使用 <code>set to</code> 语句赋值</p>

<pre><code class="language-applescript">set firstList to {100, 200.0, &quot;Number&quot;, -10}
set emptyList to {}
</code></pre>

<p>list 中也可以包含 list，例如：</p>

<pre><code class="language-applescript">set listOfList to {1, &quot;2&quot;, firstList}
</code></pre>
<br/>
<h2 id="toc_2">获取/更改值</h2>

<p>获取和更改列表中的元素:</p>

<ol>
<li><p>获取 list 中指定序号的元素有多种方法：</p>
<pre><code class="language-applescript">get item 2 of arr3  -- 获取第二个元素，即123
get 2nd item of arr3<br/>
get the second item of arr3 --该种方式只能用到tenth<br/>
set the 2nd item of modifiedList to &quot;2nd&quot;<br/>
get item -1 of arr3 -- -1表示最后一个，-2表示倒数第2个<br/>
get items 2 through 5 of arr3 -- 获取第2到第5个元素
</code></pre>
<p>可以用 <code>the last item</code> 关键字来获取列表中的最后一个元素；貌似没有 <code>the first item</code> 关键字。</p>
<p><strong>注：list 的序号从 1 开始</strong>，没有<code>item 0</code>。</p></li>
<li><p>使用<code>some item of</code>选择列表中的随机元素赋值</p></li>
</ol>
<br/>
<h2 id="toc_3">添加元素</h2>

<p>使用 <code>set the end of 列表名 to 元素</code> 添加元素到列表末尾</p>

<pre><code class="language-applescript">set the end of arr3 to &quot;new&quot;  --在最后添加一个元素 &quot;new&quot;
</code></pre>
<br/>
<h2 id="toc_4">合并</h2>

<p>使用 &amp; 运算符可以直接将若干个列表中的元素合并并形成一个新的列表：</p>

<pre><code class="language-applescript">set arr3 to arr1 &amp; arr2  -- 合并
</code></pre>
<br/>
<h2 id="toc_5">获取元素个数</h2>

<p>使用 <code>(the) length</code> 或 <code>(the) count</code> 关键字获取列表的元素个数</p>

<pre><code class="language-applescript">get the length of arr3
get the count of arr3
</code></pre>
<br/>
<h2 id="toc_6">获取逆序后的列表</h2>

<p>要逆向获取子列表，需要用到 <code>reverse</code> 关键字</p>

<pre><code class="language-applescript">get reverse of arr3
</code></pre>
<br/>
<h2 id="toc_7">类型转换</h2>

<pre><code class="language-applescript">set arr3 to {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;}
get arr3 as string --将数组的元素凭借成一个字符串
</code></pre>
<br/>
<h2 id="toc_8">获取子列表</h2>

<p>获取子列表:<br/>
使用 <code>items 开始序号 through 结束序号 of</code> 可以获取 list 中的子列表：</p>

<pre><code class="language-applescript">set longList to {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
set shortList to items 6 through 10 of longList
</code></pre>

<p>结果输出为：<code>{6, 7, 8, 9, 10}</code></p>

<p>注：从结束序号取到开始序号的方式获取的子列表是相同的，例如：</p>

<pre><code class="language-applescript">set shortList to items 10 through 6 of longList
</code></pre>

<p>结果输出为：<code>{6, 7, 8, 9, 10}</code></p>

<p>要逆向获取子列表，需要用到 <code>reverse</code> 关键字，例如：</p>

<pre><code class="language-applescript">set reversedList to reverse of longList
</code></pre>

<p>结果输出为：<code>{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}</code></p>

<hr/>

<h2 id="toc_9">String 与 List</h2>

<p>将 String 转换为 List，方法就是在 <code>set to</code> 语句后加一个 <code>as list</code> ：</p>

<pre><code class="language-applescript">-- string to list
set stringNotConvert to &quot;string&quot;
set convertStringToList to stringNotConvert as list
</code></pre>

<p>输出结果为：<code>{&quot;string&quot;}</code></p>
<br/>
<p>使用 <code>&amp;</code> 可以连接 string 和 list 变量，结果的类型由 <code>&amp;</code> 运算符之前的变量类型决定，例如：</p>

<pre><code class="language-applescript">set stringBeforeAnd to &quot;string&quot;
set listBeforeAnd to {&quot;list&quot;}
set stringAndList to stringBeforeAnd &amp; listBeforeAnd -- &amp;之前的变量是一个string
</code></pre>

<p>输出结果为：<code>&quot;stringlist&quot;</code></p>

<p>另一种情况：</p>

<pre><code class="language-applescript">-- string &amp; list or list &amp; string
set stringBeforeAnd to &quot;string&quot;
set listBeforeAnd to {&quot;list&quot;}
-- set stringAndList to stringBeforeAnd &amp; listBeforeAnd -- 注释掉这段代码
set listAndString to listBeforeAnd &amp; stringBeforeAnd -- &amp;之前的变量是一个list
</code></pre>

<p>输出结果为：<code>{&quot;list&quot;, &quot;string&quot;}</code></p>

<p>这样的写法不够明确，将上面的代码改进如下：</p>

<pre><code class="language-applescript">-- A better way
set stringAndList to (listBeforeAnd as string) &amp; stringBeforeAnd
set listAndString to (stringBeforeAnd as list) &amp; listBeforeAnd
</code></pre>

<p>更好的做法是使用 <code>as</code> 关键字做出变量类型的显式声明。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String 字符串、Text 文本型]]></title>
    <link href="https://gk0wk.github.io/15735827866089.html"/>
    <updated>2019-11-13T02:19:46+08:00</updated>
    <id>https://gk0wk.github.io/15735827866089.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>String 类和未提及的 Unicode Text 类是 AppleScript 2.0 的概念，现在已经被 Text 类完全替代。但是为了向下兼容，保留了这两个类。</p>

<p>text, string, and Unicode text will all compare as equal<br/>
————《AppleScript Language Guide》2008 年 3 月版</p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>
<br/>
<h2 id="toc_0">使用 set to 语句赋值</h2>

<pre><code class="language-applescript">set emptyString to &quot;&quot;
set aSpaceString to &quot; &quot;
set helloString to &quot;Hello&quot;
set AppleScriptString to &quot;AppleScript&quot;
</code></pre>

<ul>
<li>字符串用双引号括起来</li>
<li>转义字符<code>\&quot;</code>输出双引号</li>
<li>转义字符<code>\\</code>输出反斜杠</li>
</ul>
<br/>
<h2 id="toc_1">使用 <code>&amp;</code> 运算符连接字符串</h2>

<p>可以使用 “&amp;” 运算符将几个字符串连结在一起：</p>

<pre><code class="language-applescript">set stringAndString to (helloString &amp; aSpaceString &amp; AppleScriptString)
</code></pre>
<br/>
<h2 id="toc_2">获取字符串变量的长度</h2>

<p>使用关键字 <code>the length of</code> 来获取字符串变量的长度：</p>

<pre><code class="language-applescript">get the length of stringAndString
</code></pre>

<p>输出结果为17。</p>
<br/>
<h2 id="toc_3">将字符串分割成字符组成的列表(list)</h2>

<p>使用 <code>every character of</code> 或 <code>characters of</code>：</p>

<pre><code class="language-applescript">set charList to every character of strXY
set charList to characters of strXY
</code></pre>
<br/>
<h2 id="toc_4">将字符串分割成单词(以空格分隔)组成的列表(list)</h2>

<p>使用 <code>every word of</code> 或 <code>words of</code>：</p>

<pre><code class="language-applescript">set wordList to every word of strXY
set wordList to words of strXY
</code></pre>

<p>可以设置其他的分割符来分割单词：</p>

<pre><code class="language-applescript">set strXY to &quot;Hello AppleScript&quot;

-- 通过 AppleScript&#39;s text item delimiters 来指定分隔号，然后通过 every text item of 来实现分割
-- 注意要首先保存 AppleScript&#39;s text item delimiters，在分割字符串完成后记得要将其还原
set defaultDelimiters to AppleScript&#39;s text item delimiters
set AppleScript&#39;s text item delimiters to &quot; &quot;
set listAfterDelimiter to every text item of strXY
set AppleScript&#39;s text item delimiters to defaultDelimiters
</code></pre>

<p>结果为：<code>{&quot;Hello&quot;,&quot;AppleScript&quot;}</code></p>

<p>注：使用 &quot;&quot; 分割字符串结果为：<code>{&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;&quot;,&quot;A&quot;,&quot;p&quot;,&quot;p&quot;,&quot;l&quot;,&quot;e&quot;,&quot;S&quot;,&quot;c&quot;,&quot;r&quot;,&quot;i&quot;,&quot;p&quot;,&quot;t&quot;}</code></p>

<p>可以将分割后的 list 恢复为一个 string。恢复过程是一个逆向的过程，方法如下：</p>

<pre><code class="language-applescript">-- Restore list after delimiter to string
-- 这里也要保存和还原 AppleScript&#39;s text item delimiters。
set defaultDelimiters to AppleScript&#39;s text item delimiters
set AppleScript&#39;s text item delimiters to&quot; &quot;
set restoredString to listAfterDelimiter as string
set AppleScript&#39;s text item delimiters to defaultDelimiters
get restoredString
</code></pre>
<br/>
<h2 id="toc_5">提取指定位置的字符、单词</h2>

<p>提取指定未知的几个字符或单词，结果为 List ：</p>

<pre><code class="language-applescript">characters 3 through 5 of &quot;A String&quot; -- 结果:{&quot;S&quot;, &quot;t&quot;, &quot;r&quot;}
words 3 through 5 of &quot;我的名字叫张三&quot; -- 结果:{&quot;名字&quot;, &quot;叫&quot;, &quot;张三&quot;}
</code></pre>

<p>提取特定位置的一个字符或单词，结果为 Text ：</p>

<pre><code class="language-applescript">word 2 of &quot;This is a text&quot;
character 3 of &quot;This is a text&quot;
ninth character of &quot;This is a text&quot;
</code></pre>

<ul>
<li>第一个字符的位置是1，而不是0；</li>
<li><code>through</code> 可以缩写为 <code>thru</code>；</li>
<li>不推荐用序数词方法获得一个单词或字符；</li>
<li>不推荐对于中文引用 “word” 相关语句。</li>
</ul>

<hr/>

<h2 id="toc_6">字符串比较</h2>

<p>在对字符串进行某种比较(<code>=</code>、<code>&gt;</code>等)时，可以设置忽略或者考虑某种特性，特性可以是：</p>

<ol>
<li><strong>case</strong> 大小写</li>
<li><strong>diacriticals</strong> 字母变调符号 (如 e 和 é)</li>
<li><strong>hyphens</strong> 连字符 (-)</li>
<li><strong>numeric strings</strong> 数字化字符串 (默认是忽略的)，用于比较版本号时启用它。</li>
<li><strong>punctuation</strong> 标点符号 (,.?! 等等, 包括中文标点)</li>
<li><strong>white space</strong> 空格</li>
</ol>

<p>使用<code>considering</code>开启考虑某种特性：</p>

<pre><code class="language-applescript">considering numeric strings
    if &quot;10.3&quot; &gt; &quot;9.3&quot; then
        display alert &quot;10.3 &gt; 9.3&quot;
    end if
end considering
</code></pre>

<p>使用<code>ignoring</code>关闭考虑某种特性：</p>

<pre><code class="language-applescript">ignoring case
    if &quot;AAA&quot; = &quot;aaa&quot; then
        display alert &quot;AAA equal aaa when ignoring case&quot;
    end if
end ignoring
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Number 数字]]></title>
    <link href="https://gk0wk.github.io/15735827612332.html"/>
    <updated>2019-11-13T02:19:21+08:00</updated>
    <id>https://gk0wk.github.io/15735827612332.html</id>
    <content type="html"><![CDATA[
<p>分为整数(integer)和实数(real)两大类，二者都可以是负数，赋值的时候将自动判断是整数还是实数，二者运算会自动对齐类型；所以一般情况下不用在意到底是整数还是实数，只要知道它们都是 Number 就可以了。</p>

<span id="more"></span><!-- more -->

<p>Number 类型变量之间可以进行四则运算(<code>+-*/</code>)和乘方(<code>^</code>)运算等</p>

<pre><code class="language-applescript">set x to 2
get x
set y to 3.33223
get y
set xy to x * y
set x3 to y ^ 3
</code></pre>

<p>最终 xy = 6.66446，x ^ 3 = 37.000271431361。输出结果可以在运行结果区中看到（只看到最后一行的变量值）。</p>

<hr/>

<h2 id="toc_0">Number 和 String 之间的类型互换</h2>

<p>使用 <code>as</code> 来相互转换 Number 和 String：</p>

<pre><code class="language-applescript">set numberToString to 100 as string
set stringToNumber to &quot;10&quot; as number
set a to &quot;1.99&quot; as integer -- 精度丢失
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Date 日期型]]></title>
    <link href="https://gk0wk.github.io/15735827313345.html"/>
    <updated>2019-11-13T02:18:51+08:00</updated>
    <id>https://gk0wk.github.io/15735827313345.html</id>
    <content type="html"><![CDATA[
<p>如: <code>date &quot;2009 年 8 月 30 日星期日 下午 12:31:34&quot;</code></p>

<span id="more"></span><!-- more -->

<p>此格式的具体形式由 “系统偏好设置 - 语言与文本” 的相关设置决定。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boolean 布尔型]]></title>
    <link href="https://gk0wk.github.io/15735826951271.html"/>
    <updated>2019-11-13T02:18:15+08:00</updated>
    <id>https://gk0wk.github.io/15735826951271.html</id>
    <content type="html"><![CDATA[
<p>仅仅包含两个值: <code>True</code> 和 <code>False</code> （不区分大小写）</p>

<span id="more"></span><!-- more -->

<pre><code class="language-applescript">set a to true
set b to false
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AppleScript基本数据类型]]></title>
    <link href="https://gk0wk.github.io/15735826629445.html"/>
    <updated>2019-11-13T02:17:42+08:00</updated>
    <id>https://gk0wk.github.io/15735826629445.html</id>
    <content type="html"><![CDATA[
<p>AppleScript 有多种数据类型：</p>

<ol>
<li><a href="15735826951271.html">Boolean 布尔型</a></li>
<li><a href="15735827313345.html">Date 日期型</a></li>
<li><a href="15735827612332.html">Number 数字</a></li>
<li><a href="15735827866089.html">String 字符串、Text 文本型</a></li>
<li><a href="15735828924204.html">List 列表</a></li>
<li><a href="15735829601096.html">Record 记录</a></li>
</ol>

<span id="more"></span><!-- more -->

<p>在 AppleScript 中声明一个变量使用 <code>set xxx to xxx</code>的语法：</p>

<pre><code class="language-applescript">set theString to &quot;Hello World&quot;
</code></pre>

<p>可以使用 <code>class of</code> 语句确定一个变量的类型：</p>

<pre><code class="language-applescript">-- 这是注释
set str to &quot;string&quot;
class of str -- 返回 &quot;text&quot;
</code></pre>

<hr/>

<h2 id="toc_0">强制类型转换</h2>

<p>AppleScript 拥有类型对齐功能(比如<a href="AppleScript%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/List%20%E5%88%97%E8%A1%A8">List 和 String 的拼接</a>)，但有时候无法完成转换或者转换结果与我们预期设想不同，就需要显式的强制类型转换(Coercion)。</p>

<p>使用 <code>as</code> 关键字强制类型转换：</p>

<pre><code class="language-applescript">&quot;1.99&quot; as real    -- 1.99 (real)
&quot;1.99&quot; as integer -- 2 (integer) 精度丢失
&quot;1&quot; as real       -- 1.0  (real)

&quot;text&quot; as list    -- { &quot;text&quot; }

{ a: 1, b: 2 } as list -- { 1, 2 } 精度丢失(标识符丢失)
</code></pre>

<p>不是所有的数据都能够强制类型转换，不要纠结于此，做有意义的事：</p>

<pre><code class="language-applescript">&quot;text2&quot; as number -- 错误! Text 中包含了无法转换成数字的字符。
1 as record -- 错误! 无法获得标识符。
{1, 2} as record -- 错误! 无法获得标识符。
</code></pre>

<hr/>

<h2 id="toc_1">使用 <code>copy</code> 进行深拷贝</h2>

<p><code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Date</code>在使用<code>set to</code>的时候，是将实际的数据拷贝一份给另一个变量。但是对于<code>List</code>和<code>Record</code>，则是创建一份原对象的应用。</p>

<p>例如以下指令：</p>

<pre><code class="language-applescript">set A to {1, 2, 3}
set B to A
set A to {4, 5, 6}
</code></pre>

<p>过程为：A指向数据<code>{1, 2, 3}</code>；B指向A所指向的数据<code>{1, 2, 3}</code>；A指向新的数据<code>{4, 5, 6}</code>。</p>

<p>最后的结果为 A = <code>{4, 5, 6}</code>, B = <code>{1, 2, 3}</code>。</p>
<br/>
<p>再看一个例子：</p>

<pre><code class="language-applescript">set A to {1, 2, 3}
set B to A
set item 2 of A to 20
</code></pre>

<p>过程为：A指向数据<code>{1, 2, 3}</code>；B指向A所指向的数据<code>{1, 2, 3}</code>；修改A所指向的数据的第二项为20。</p>

<p>最后的结果为 A = B = <code>{1, 20, 3}</code>。</p>
<br/>
<p>所以 <code>List</code> 的变量理解为指针或者引用会更好一些， <code>Record</code> 同理。</p>

<p>如果想要进行深层拷贝，就要用到<code>copy</code>：</p>

<pre><code class="language-applescript">set A to {1, 2, 3}
copy B to A
set item 2 of A to 20
</code></pre>

<p>最后的结果为 A = <code>{1, 20, 3}</code>, B = <code>{1, 2, 3}</code>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AppleScript的语言逻辑]]></title>
    <link href="https://gk0wk.github.io/15735825376552.html"/>
    <updated>2019-11-13T02:15:37+08:00</updated>
    <id>https://gk0wk.github.io/15735825376552.html</id>
    <content type="html"><![CDATA[
<p>AppleScript是一门面向对象的语言，同时也是仿照英语书写的语言，所以结合了二者的一些性质，形成以下逻辑：</p>

<span id="more"></span><!-- more -->

<ul>
<li><p>AppleScript是<a href="%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80">形式语言</a>，其基本的<a href="%E6%96%87%E6%B3%95%E8%AE%B0%E5%8F%B7">文法记号</a>(也就相当于文章的单词，最小语法单位)有四类：名词、动词、运算附和修饰词。<br/>
<strong>名词</strong><br/>
被动词操作，名词对应着<code>对象</code>，是类、属性、元素或基本类型变量。</p>
<p><strong>动词</strong><br/>
操作名词，或者被承接动词的结果，对应着<code>命令</code>。动词操作名词会返回到一个结果。</p>
<p><strong>运算符</strong><br/>
操作名词或者动词的结果，如逻辑和算术运算、赋值运算(set、copy)、class of等。返回到一个结果。</p>
<p><strong>修饰词</strong><br/>
修饰名词、动词，或者组成特定的流程控制结构。</p></li>
<li><p>名词(对象)中<br/>
基本类型变量<a href="AppleScript%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">有若干种</a>，可以组成<code>类</code>；<br/>
类中包含有基本类型变量(作为<code>属性</code>)，也可以包含另一个类(作为<code>元素</code>)。</p></li>
<li><p>名词只能与特定的某些动词相搭配才具有意义。</p></li>
<li><p>修饰词需要与特定的名词动词搭配才具有意义。</p></li>
<li><p>运算符需要与特定的名词动搭配才具有意义。</p></li>
<li><p>类和命令分别属于不同的<code>套件</code>，构成一类用途；套件属于某个应用程序。套件中某个对象属于该程序，套件中某个命令是该程序的行为。</p></li>
<li><p>类可以继承，可以被定义多次。</p></li>
</ul>

<p>AppleScript是脚本语言，可以定义函数，但是是逐行执行的，每一行执行之后都会得到一个执行结果，存在预定义变量 <strong>result</strong> 中；脚本完全结束后，将输出当前 <strong>result</strong> 的结果(最后一行执行的结果)。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AppleScript]]></title>
    <link href="https://gk0wk.github.io/15735824358278.html"/>
    <updated>2019-11-13T02:13:55+08:00</updated>
    <id>https://gk0wk.github.io/15735824358278.html</id>
    <content type="html"><![CDATA[
<p><a href="AppleScript">AppleScript</a> 是 Mac OS X 内置的一种功能强大的脚本语言，能够帮你在 mac 上实现自动化。其语法和英语自然语法很像。</p>

<span id="more"></span><!-- more -->

<ul>
<li><a href="AppleScript">AppleScript</a> 的采用 <a href="Unicode">Unicode</a> 文字编码，并且不区分大小写。</li>
</ul>

<p><a href="AppleScript">AppleScript</a> 本身是一门<a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80">面向对象语言</a>，它拥有三个重要的 OO 术语: <code>对象(Object)</code>、<code>属性(Property)</code> 和 <code>命令(Command)</code>。命令又称方法（Method）。</p>

<p>其核心为通过访问应用程序提供出来的一系列消息动作API来获取数据和对应用程序进行某种操作，OO的性质很强。<a href="AppleScript">AppleScript</a> 本身具有的功能很少，有必要的数据类型、流程控制和一些简单的输入输出，剩下的都是依靠和应用程序的通信来完成的。</p>

<hr/>

<p>AppleScript 包括如下三部分：</p>

<ul>
<li>  AppleScript 语言</li>
<li>  AppleScript 脚本文件</li>
<li>  AppleScript 脚本解释器</li>
</ul>
<br/>
<h2 id="toc_0">关于 AppleScript 的编写与执行</h2>

<ul>
<li>在 mac 中自带 <code>Automator.app</code> 和 <code>Script Editor.app</code> 均可以编写脚本。</li>
<li>其中 <code>Automator.app</code> 是可视化的，但是功能很简单。而 <code>Script Editor.app</code> 很全面。</li>
<li>也可以用 <code>Xcode</code> 编写 <code>Cocoa - AppleScript Application</code>。<a href="https://github.com/BenXia/AppleScriptStudy/tree/master/5_%E5%BF%AB%E5%8F%91%E9%82%AE%E4%BB%B6OC%E7%89%88%E6%9C%AC">比如这个</a></li>
<li>Alfred 也可以用。</li>
<li>命令行直接使用 <code>osascript [脚本文件的路径]</code>来执行，配合<a href="%E8%BE%93%E5%87%BA%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91">输出流重定向</a>和其他脚本(如<a href="Python">Python</a>和<a href="Linux%20Shell">Linux Shell</a>)可以实现更多自动化功能。</li>
</ul>

<hr/>

<h2 id="toc_1">更多参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html">AppleScript Language Guide 官方文档</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/MakeaSystem-WideService.html#//apple_ref/doc/uid/TP40016239-CH46-SW1">Mac Automation Scripting Guide</a></li>
<li><a href="https://support.apple.com/zh-cn/guide/terminal/trml1003/mac">AppleScript 与 Shell 的互相调用</a></li>
<li><a href="https://blog.csdn.net/SysProgram/article/details/46817917">Objective-C 运行 AppleScript 脚本</a></li>
<li><a href="https://www.aliyun.com/jiaocheng/376240.html?spm=5176.100033.2.11.2a7d9a70mlzSWR">如何让 Cocoa App 支持 AppleScript</a></li>
<li><a href="http://www.docin.com/p-515251458.html">AppleScript for Absolute Starters</a></li>
<li><a href="http://ishare.iask.sina.com.cn/f/33325750.html">Apple Automator with AppleScript</a></li>
<li><a href="https://developer.apple.com/library/archive/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/Introduction.html#//apple_ref/doc/uid/TP40014508-CH111-SW1">JavaScript for Automation</a></li>
<li><a href="https://github.com/JXA-Cookbook/JXA-Cookbook/wiki/Foreword">JXA-Cookbook</a></li>
<li><a href="https://wenku.baidu.com/view/41c783c3aa00b52acfc7ca09.html">Mac 的自动化 AppleScript 终极入门手册</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Script Editor.app]]></title>
    <link href="https://gk0wk.github.io/15735795193541.html"/>
    <updated>2019-11-13T01:25:19+08:00</updated>
    <id>https://gk0wk.github.io/15735795193541.html</id>
    <content type="html"><![CDATA[
<p>目前可以支持 AppleScript 、 JavaScript 、 Objective-C 三种语言来实现自动化，这里暂时介绍 AppleScript。</p>

<span id="more"></span><!-- more -->

<p>Script Editor 中带有文档库和模板，用起来还是比较方便的。</p>

<h2 id="toc_0">Library</h2>

<p><strong>并不是所有应用程序都可以和 AppleScript 连通，需要应用程序开发者有意地留出一套供给 AppleScript 的接口才可以。</strong>，如何知道某个程序是否支持 AppleScript 以及具体提供了怎样的 API 规范，请使用 ScriptEditor.app 的 Library 来查看程序的字典 Dictionary）：</p>

<ul>
<li>方法一：菜单 [File] - [Opne Dictionary] 查看所有已知的应用程序字典。</li>
<li>方法二：将应用程序拖放到<code>Script Editor</code>图标上。</li>
<li>方法三：
<ol>
<li>菜单 [Window] - [Library]</li>
<li>可以看到已经导入的支持 AppleScript 接口的应用程序的接口文档，双击查看。</li>
<li>点击 [+] ，选定某个 <code>.app</code> 应用文件，如果支持，文档的字典将被导入；如果不支持，将会提示。</li>
</ol></li>
</ul>

<h2 id="toc_1">字典(Dictionary)</h2>

<p>字典是文档接口规范的说明，打开字典后，会出现以下界面：</p>

<p><img src="media/15735795193541/20191112000939.png" alt="字典界面"/></p>

<p>字典上边是三列，和Finder的列视图一样，自左向右展开；选中一项，下半面的文档就会跳到对应的对象的说明上。</p>

<p>先看上三列，</p>

<ul>
<li>最左边是套件列，列出了该应用字典包含的套件(一般都会包含Standard Suite，里面是一些程序的基本操作例如打开关闭文件、操作程序的窗口等)。</li>
<li>中间列显示选中的套件的内容，其中包含了若干<code>命令</code>(圆形的 C 图标)和<code>类</code>(方形的 C 图标)。</li>
<li>最右边的列显示选中的类的内容，包含了若干<code>元素</code>(E图标)和<code>属性</code>(P 图标)。</li>
</ul>

<p>要理解这些东西是怎样工作的，就应当先明白<a href="15735825376552.html">AppleScript的语言逻辑</a>。</p>

<hr/>

<p>理解过逻辑后，来解释说明文档该如何用。AppleScript具有英语的一些特点，所以字典看起来还真像一本英语字典。</p>

<h3 id="toc_2">动词</h3>

<p>先看”动词“：</p>

<p><img src="media/15735795193541/20191112142040.png" alt="动词"/></p>

<p>单词用法部分，最上面的主体 <strong>make</strong> 肯定要写上，后面相当于是这个动词的“参数”，每一行列出一个参数，<code>:</code>之前的为参数格式说明，<code>:</code>之后的为对参数的说明。</p>

<p>参数有必选参数和可选参数，被<code>[]</code>括起来的是可选参数(使用的时候不加<code>[]</code>)。使用时，参数之间用空格分开。<code>:</code>之前，<strong>粗体</strong>内容按原样写上，非粗体则替换为对应的对象。</p>

<p>可以注意到非粗体部分的名称是不一样的，不同的名称说明可以充当参数的对象是不同的，有这么几种：</p>

<ul>
<li>数据类型<code>number</code>、<code>text</code>、<code>boolean</code>、<code>date</code>、<code>list</code>、<code>record</code>或者类名：可以使用这些类型的变量或者常量作为参数。</li>
<li><code>any</code>：可以用任何对象作参数。</li>
<li><code>type</code>：类型名、类名。</li>
<li><code>specifier</code>或者<code>xxx specifier</code>：某个对象实例(变量名或者返回值)，<code>xxx</code>是某个类名，代表这个实例应当是某种类型的。</li>
<li><p>还有一种特殊的，例如 [<strong>saving</strong> yes/no/ask] 是说只能写<code>yes</code>、<code>no</code>和<code>ask</code>三种，这是一种枚举类型的参数，一般枚举参数上会有链接，点击会调到对应的枚举类型上去：</p>
<p><img src="media/15735795193541/20191112145218.png" alt="枚举说明"/></p></li>
</ul>
<br/>
<h3 id="toc_3">名词</h3>

<p><img src="media/15735795193541/20191112161103.png" alt="名词"/></p>

<p>比较有意思的是第一行方括号中的内容，见过两种：</p>

<ul>
<li><code>[see also xxx]</code> 是指，这个名词(类)还在其他 Suit 中被定义过，那么下方就会展示另一处定义的内容(箭头所指)；</li>
<li><code>[inh. xxx]</code> 是指，这个类继承于另外一个类。如果是 <code>[inh. A &gt; B]</code> 就说明该类继承于A类，而A类又继承于B类，那么下方就会展示基类的内容。</li>
</ul>
<br/>
<p><code>元素(ELEMENT)</code>：一个类中的某元素不一定只有一个(从图中的<code>documents</code>和<code>windows</code>的<code>s</code>就可以看出来，毕竟第三列中是<code>document</code>和<code>window</code>)，很好理解， appliction 可以有很多个 window ，每一个都是其元素。</p>

<pre><code class="language-text">* 使用 `(the) count of [元素名]` 确定同类型元素有几个；
* 使用 `[元素名] [序号(可以是integer变量)]` 来获取某一个元素；`the last of`、`the first of` 也可以，`item xxx of`则是不可以的——因为这不是`item`而是`element`。
</code></pre>
<br/>
<p>具体来看一下 <code>属性(PROPERTIES)</code>：</p>

<ul>
<li><strong>粗体</strong> 是属性的名称；</li>
<li>括号内第一项是属性的类型；</li>
<li>括号内第二项是属性的读写权限；</li>
<li><code>:</code> 后面是属性的解释。</li>
</ul>

<h2 id="toc_4">编辑器</h2>

<p>创建脚本、调试这些是基本操作，略。</p>

<p>当你在编辑器内完成输入上面的代码后，按下上面的 <code>Compile</code> 铁锤图标。如果你的语法是正确的话，你所输入的代码会被自动格式化并改变颜色。如果你输入的时候出现了错误，当你编译的时候编辑器会告诉你哪一块出错了，并尝试告诉你它认为错误是什么。下面是编辑器默认的一些颜色分别代表什么，你可以在菜单栏的 [AppleScript Editor] - [Preferences] 里看到并修改。</p>

<p>你的代码成功编译后，再按 <code>Run</code> 图标，会运行脚本。在运行一脚本时，编辑器会告诉你运行的结果是什么，或者什么被返回了。脚本编辑器会将结果显示在下半部分的结果区中。</p>

<hr/>

<h2 id="toc_5">其他窍门</h2>

<ul>
<li>按下 esc 键，会出现代码补全菜单</li>
<li>在编辑区点击右键（或按住 control 键再点击左键）呼出上下文菜单：在上下文菜单中我们可以将 AppleScript 语句快速地插入到编辑区中</li>
</ul>

<h3 id="toc_6">编辑器支持代码补全和缩写：</h3>

<p>你可以输入：</p>

<pre><code class="language-applescript">tell app &quot;Finder&quot;
end
</code></pre>

<p>在编译后将被替换为：</p>

<pre><code class="language-applescript">tell application &quot;Finder&quot;
end tell
</code></pre>

<p>在编写 AppleScript 脚本时，是不区分大小写的，当然在编译过后也会被替换成正确的大小写形式。</p>

<p>其他例子有：</p>

<ul>
<li>application 简写为 app</li>
<li>end tell/repeat/try 简写为 end</li>
<li>through 简写为 thru</li>
<li>if 语句 可省略 then</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[B+树(B+ Tree)]]></title>
    <link href="https://gk0wk.github.io/15583370060570.html"/>
    <updated>2019-05-20T15:23:26+08:00</updated>
    <id>https://gk0wk.github.io/15583370060570.html</id>
    <content type="html"><![CDATA[
<p>B+ Tree是<a href="15583364169947.html">多路搜索树(B-Tree)</a>的一种变体，在磁盘查找结构中，B+ Tree更适合文件系统的磁盘存储结构。</p>

<p>相对于<a href="15583364169947.html">多路搜索树(B-Tree)</a>来说B+ Tree更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。</p>

<span id="more"></span><!-- more -->

<hr/>

<h2 id="toc_0">概念</h2>

<blockquote>
<p>定义：一颗度为m的B+ Tree满足以下规则：</p>

<ol>
<li>整棵树的节点分为两类：叶子节点(用于存储数据)和非叶子节点(包括根节点；不存储数据，只保存关键字用作索引)。</li>
<li>非叶子节点：
<ol>
<li>根节点有2 ~ m个分支(子节点)；</li>
<li>根节点可以是叶子节点也可以是非叶子节点；</li>
<li>其他的非叶子节点有\(\lceil m/2 \rceil\) ~ m个分支(子节点)；</li>
<li>非叶子节点的 分支点数=关键字数-1 (或者 分支点数=关键字数 ，MySQL用的是这一种)；</li>
<li>两个关键字k,,i,,、k,,i+1,,之间的分支内的关键字/数据，范围在 [k,,i,,,k,,i+1,,) 之间(最后一个分支大于等于前一个关键字)。</li>
<li>所有的非叶子节点关键字都同时存在于某个叶子节点，且在该叶子节点元素中是最小元素。</li>
</ol></li>
<li>叶子节点：
<ol>
<li>叶子节点在同一层；</li>
<li>所有叶子节点通过指针链相连，且叶子节点本身按关键字的大小从小到大顺序排列(从左连到右)。</li>
</ol></li>
<li>自然插入而不进行删除操作时，叶子节点的数据容量为\([\lfloor m/2\rfloor ,m-1]\)，非叶子节点的关键字数量容量为\(\left[\lceil m/2\rceil -1,m-1\right]\)。</li>
</ol>
</blockquote>

<p>如：</p>

<p><img src="media/15583370060570/15583374321306.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<ul>
<li>由于叶子节点和非叶子节点的功能不同(叶子节点之存储数据，非叶子节点只作为“路标”)，所以一般来讲两种节点的数据结构是不同的 ( _非叶子节点的结构可以参考B-Tree|多路搜索树(B-Tree)，叶子节点可以做成“数据数组+长度+指向下一个叶子节点的指针”这样的节点结构_) 。</li>
<li>B+树有两个头指针，一个指向根节点、一个指向最小的叶子节点。</li>
<li><p>在进行删除操作时，涉及到索引节点填充因子和叶子节点填充因子，一般可设叶子节点和索引节点的填充因子都不少于50%。</p></li>
<li><p><strong>注意：由于本文所用的是“左大等右小于”的判断方式，所以关键字是每个节点的最小元素，再删除的时候删除最小值需要上溯修改关键字；如果换成“左大于右小于”，关键字就是每个节点的最大元素了，删除逻辑需要调整。</strong></p></li>
</ul>

<hr/>

<h2 id="toc_1">操作</h2>

<p>B+ Tree是<a href="15583364169947.html">多路搜索树(B-Tree)</a>的变种，在查找、插入和删除操作上和<a href="15583364169947.html">多路搜索树(B-Tree)</a>很类似。</p>

<h3 id="toc_2">查找</h3>

<ul>
<li>从根节点开始，所寻找的值依次和节点的k-1个关键字比较：
<ul>
<li>若小于该关键字，那么进入该关键字左侧的分支重复搜索动作；</li>
<li>若大于等于该关键字，
<ul>
<li>若这是该节点的最后一个关键字，那么进入该关键字右侧的分支重复搜索动作；</li>
<li>若不是最后一个关键字，所搜索值继续和下一个关键字比较。</li>
</ul></li>
</ul></li>
<li>如果进入了叶子节点，那么就遍历叶子节点的数组找到所要的值；找不到则退出。</li>
</ul>

<h3 id="toc_3">遍历</h3>

<ul>
<li>遍历操作，先去找最左侧的树，然后顺着叶子节点的指针一路摸下去就可以。</li>
<li>如果存储了最小叶子节点的指针，那就更方便了。</li>
</ul>

<h3 id="toc_4">插入</h3>

<p>首先明确，对于一个阶为m的B+ Tree：</p>

<ol>
<li>根节点的关键字容量为\(1\sim\left(m-1\right)\)；</li>
<li>中间节点和叶子节点的关键字容量为\(\left(\lceil\frac{m}{2}\rceil -1\right)\sim\left(m-1\right)\)。</li>
<li>叶子节点的容量为\(\lfloor m/2\rfloor \sim (m-1)\)。</li>
</ol>

<p>插入元素可能会破坏B+ Tree的规则(叶子节点容量超过上限)，解决方法就是 &#39;&#39;拆分叶子节点&#39;&#39;。同时，非叶子节点也需要拆分。</p>

<ul>
<li>Step 0：如果这是一颗空树，根节点作为叶子节点，把元素直接放入；</li>
<li>Step 1：搜索触底到达叶子节点，插入的元素；</li>
<li>Step 2：看元素数量是否超过了节点容量上限：
<ul>
<li>如果没有超过，可以返回；</li>
<li>如果超过了，取叶子节点的元素序列中的中间元素(如果有两个就取中间右侧，因为规则2.4是“大于等于”)作为新的关键字，将叶子节点分为两个(取的元素不从叶子节点删除，分给右边的节点)，挂在新的关键字两边(如果叶子节点非根节点，那么左边的节点不动，依旧挂在原来的位置)；该关键字放到这之上的非叶子节点；如果如果叶子节点是根节点，那么新的关键字变成非叶子节点的根节点。</li>
</ul></li>
<li>Step 3：如果叶子节点非根节点，继续调整关键字：这里就和 <a href="15583364169947.html">多路搜索树(B-Tree)</a> 的插入上翻维护一样了，只是注意取中间右侧的关键字(上升的关键字需要删除)，不断上翻维护直到不超过关键字容量上限。</li>
</ul>

<p>就取序列中间(如果有两个中间的就取一个)的一个关键字，两侧的关键字分裂为两个新的节点接在选出的关键字两侧。把这个选出的关键字插入上一层节点中(调回执行Step 2)——如果之前的节点是根节点就把该关键字作为新的根节点。</p>

<h3 id="toc_5">删除</h3>

<p>B+ Tree的删除和<a href="15583364169947.html">多路搜索树(B-Tree)</a>很像，只是记得改变每个叶子节点最小值之后需要上溯修改关键字。</p>

<ul>
<li>Step 0：如果这是一颗空树，或者没有找到要删除的值，返回。</li>
<li>Step 1：删除节点：找到叶子节点的该元素，删除；
<ul>
<li>如果该节点此时的元素数量已经小于容量下限：
<ul>
<li>如果该叶子节点左侧和右侧的叶子节点，都没有达到最小容量下限，就拿左侧最大的元素给该节点；</li>
<li>如果该叶子节点左侧叶子节点已达到下限而右侧叶子节点没有，就用右侧最小的来给它；</li>
<li>如果该叶子节点右侧叶子节点已达到下限而左侧叶子节点没有，同理；</li>
<li>如果该叶子节点左右两侧叶子节点都达到最小下限，就让该节点与左侧(或者右侧)叶子节点合并，删除该点左侧(或者右侧)的关键字。</li>
</ul></li>
<li>如果没有小于容量下限，不作调整。</li>
</ul></li>
<li>Step 3：更新关键字
<ul>
<li>如果上一步没有发生叶子节点合并，但是该叶子节点或者右侧叶子节点的最小元素已经改变，就需要更新关键字：
<ul>
<li>取新的最小元素，覆盖之前的该叶子节点左侧的关键字(如果是该叶子节点最小元素发生改变)或者右侧的关键字(如果是该叶子节点的右侧叶子节点最小元素发生改变)；</li>
<li>进一步，如果上一层非叶子节点中，所修改的关键字也是该节点中最小的关键字，就需要继续向上修改，依此循环直至不再是最小关键字。</li>
</ul></li>
<li>如果上一步发生了叶子节点的合并，也需要调整关键字：
<ul>
<li>如果上层非叶子节点的关键字数量已小于容量下限，就需要做 &#39;&#39;左旋、右旋或者合并&#39;&#39; ，方法和 <a href="15583364169947.html">多路搜索树(B-Tree)</a> 一样(Step 3.2)、一路上溯——但是需要注意几点：
<ul>
<li>① 左旋右旋移动关键字的时候，别忘了把所属分支也挪过来！</li>
<li>② 如果非叶子节点(如果修改过左右非叶子节点，那么左右也要看)的最小关键字更新了，需要继续上溯更新；</li>
<li>③ &#39;&#39;如果已经上溯到根节点，并且根节点也小于容量下限了，那么合并的叶子节点将作为根节点。&#39;&#39;</li>
</ul></li>
<li>如果上层非叶子节点关键字数量没有低于容量下限，但是如果是该非叶子节点的第一个叶子节点和其右侧节点合并，那么上一层的非叶子节点最小关键字将改变，按照上面的方法一路上溯更新。</li>
</ul></li>
</ul></li>
</ul>

<p>这里有一些带图示的<a href="https://yq.aliyun.com/articles/9280">例子</a>有助于理解。</p>

<hr/>

<h2 id="toc_6">B+ Tree对B-Tree的改进</h2>

<p>相较于<a href="15583364169947.html">多路搜索树(B-Tree)</a>，B+ Tree的非叶子节点没有包括有效的元素信息(是这样的，在实际存储中，树中存储的不可能只有一个值，而是一段数据+一个ID值，所以说B+ Tree非叶子节点没有有效的元素信息)，非叶子节点中的关键字只作为叶子结点元素的索引而存在，需要的信息全都在叶子节点上。</p>

<p>B+ Tree严格意义上说已经不是树，它的叶子结点之间也有指针链接。B+ Tree的非终结点中并不含有关键字的信息。</p>

<ol>
<li><p>查找对比：</p>
<ol>
<li>B+ Tree的层级更少：在磁盘页大小相同的情况下，相较于<a href="15583364169947.html">多路搜索树(B-Tree)</a>，B+ Tree每个非叶子节点存储的关键字数更多(因为不存储元素数据)，树的层级更少所以查询数据更快；所以在相同数量的待查数据下，B+ Tree查找过程中需要调用的磁盘IO操作要少于普通<a href="15583364169947.html">多路搜索树(B-Tree)</a>树。因此B+ Tree的查找性能要好于<a href="15583364169947.html">多路搜索树(B-Tree)</a>。</li>
<li>B+ Tree的查找更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。因此同一颗B+ Tree中，任何关键字的查找比较次数都是一样的。而<a href="15583364169947.html">多路搜索树(B-Tree)</a>就不一定了，可能查找到某一个非终结点就结束了。</li>
</ol></li>
<li><p>插入删除对比：B+ Tree与<a href="15583364169947.html">多路搜索树(B-Tree)</a>在插入删除操作中的效率是差不多的。</p></li>
<li><p>B+ Tree天然具备排序功能：B+ Tree所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便。</p></li>
<li><p>数据紧密性很高(磁盘存储)，缓存的命中率也会比<a href="15583364169947.html">多路搜索树(B-Tree)</a>高，这种情况下访问更快。</p></li>
<li><p>B+ Tree全节点遍历更快：B+ Tree遍历整棵树只需要遍历所有的叶子节点即可，而不需要像<a href="15583364169947.html">多路搜索树(B-Tree)</a>一样需要对每一层进行遍历，这有利于数据库做全表扫描和范围查询。</p></li>
</ol>

<p>总体评价：在应用背景下，特别是文件结构存储中。B+ Tree的应用要更多，其效率也要比<a href="15583364169947.html">多路搜索树(B-Tree)</a>好。</p>

<ul>
<li><a href="15583364169947.html">多路搜索树(B-Tree)</a>相对于B+ Tree的优点是，如果经常访问的数据离根节点很近，而<a href="15583364169947.html">多路搜索树(B-Tree)</a>的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+ Tree快。</li>
</ul>

<hr/>

<h2 id="toc_7">参考</h2>

<ul>
<li><a href="https://juejin.im/post/5b9073f9f265da0acd209624">https://juejin.im/post/5b9073f9f265da0acd209624</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[B* 树(B* Tree)]]></title>
    <link href="https://gk0wk.github.io/15583369413094.html"/>
    <updated>2019-05-20T15:22:21+08:00</updated>
    <id>https://gk0wk.github.io/15583369413094.html</id>
    <content type="html"><![CDATA[
<p>B* Tree是<a href="15583370060570.html">B+树(B+ Tree)</a>的变种，相对于<a href="15583370060570.html">B+树(B+ Tree)</a>他们的不同之处如下：</p>

<span id="more"></span><!-- more -->

<ol>
<li><p>首先是关键字个数限制问题，<a href="15583370060570.html">B+树(B+ Tree)</a>初始化的关键字初始化个数是\(\lceil m/2\rceil\)，B* Tree的初始化个数为\(\lceil \frac{2}{3}m\rceil\)。</p></li>
<li><p>B+ Tree节点满时就会分裂，而B* Tree节点满时会检查兄弟节点是否满(因为每个节点都有指向兄弟的指针)，如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</p></li>
</ol>

<p>B* Tree在<a href="15583370060570.html">B+树(B+ Tree)</a>的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B* Tree额分解次数变得更少；</p>

<hr/>

<h2 id="toc_0">实现</h2>

<p>略。</p>

<hr/>

<h2 id="toc_1">参考</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/27700617">https://zhuanlan.zhihu.com/p/27700617</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多路搜索树(B-Tree)]]></title>
    <link href="https://gk0wk.github.io/15583364169947.html"/>
    <updated>2019-05-20T15:13:36+08:00</updated>
    <id>https://gk0wk.github.io/15583364169947.html</id>
    <content type="html"><![CDATA[
<p>多路搜索树又称<code>B~Tree</code>、<code>B树</code>、<code>B-Tree 树</code>或者<code>B-树</code>(不念“B减树”！)。B-Tree是一种自平衡树，插入和删除都需要维护。</p>

<p>B-Tree 主要用在文件系统以及部分数据库索引，比如 MongoDB。</p>

<span id="more"></span><!-- more -->

<hr/>

<h2 id="toc_0">概念</h2>

<p>B-Tree 是一种多路平衡查找树，每个节点最多包含 &#39;&#39;m&#39;&#39; 个子节点(分支)和 &#39;&#39;m-1&#39;&#39; 个元素(关键字)，m被称为B-Tree的<code>阶</code>，阶一般大于等于3。(数据库索引树中，m 的大小取决于磁盘页的大小。)</p>

<blockquote>
<p>一个m阶的B-Tree有如下特征：</p>

<ol>
<li>根节点至少有两个孩子(分支)和一个关键字；</li>
<li>每个中间节点都包含 &#39;&#39;k-1&#39;&#39; 个元素(关键字)和 &#39;&#39;k&#39;&#39; 个分支(\(\lceil\frac{m}{2}\rceil\le k\le m\))；</li>
<li>每个叶子节点都包含 &#39;&#39;k-1&#39;&#39; 个元素(关键字)(\(\frac{m}{2}\le k\le m\))；</li>
<li>所有的叶子节点都位于同一层；可以用空指针表示，是查找失败到达的位置；</li>
<li>每个节点中的元素(关键字)从小到大排列，节点中的 &#39;&#39;k-1&#39;&#39; 个元素（关键字）正好是 &#39;&#39;k&#39;&#39; 个分支包含的元素(关键字)的值域分划。</li>
</ol>

<p>所以B-Tree的每个节点的结构是这样的：</p>

<p><img src="media/15583364169947/15583368589780.jpg" alt=""/></p>

<p>节点中每个元素\(k_i\)应满足\(k_i&lt;k_{i+1}\)，同时每个分支\(p_i\)的范围应满足\(k_i&lt;p_i&lt;k_{i+1}\)</p>
</blockquote>

<p>(在这个过程中，随着元素的增多，实际情况下内存中比较次数可能很多，但是内存的比较时间与磁盘 IO 消耗相比几乎可以忽略不计。)</p>

<hr/>

<h2 id="toc_1">操作</h2>

<h3 id="toc_2">寻找</h3>

<ul>
<li>从根节点开始，所寻找的值依次和节点的k-1个关键字比较：
<ul>
<li>若小于该关键字，那么进入该关键字左侧的分支重复搜索动作；</li>
<li>若等于该关键字，就是找到了；</li>
<li>若大于该关键字，
<ul>
<li>若这是该节点的最后一个关键字，那么进入该关键字右侧的分支重复搜索动作；</li>
<li>若不是最后一个关键字，所搜索值继续和下一个关键字比较。</li>
</ul></li>
</ul></li>
<li>同时，如果进入的分支是NULL，说明没有找到匹配的值，退出搜索。</li>
</ul>

<blockquote>
<p><img src="media/15583364169947/15583368878499.jpg" alt=""/></p>

<p>以上图为例：</p>

<ul>
<li>寻找“3”：根节点看第一个关键字【3&lt;5】故到第一个分支，随后有【3==3】，找到。</li>
<li>寻找“13”：根节点看第一个关键字【13&gt;5】故看第二个关键字【13&gt;9】故到第三个分支，随后看第一个关键字【13&gt;12】故看第二个关键字【13&lt;15】故到第二个分支，随后看第一个关键字【13==13】，找到。</li>
<li>寻找“10”：根节点看第一个关键字【10&gt;5】故看第二个关键字【10&gt;9】故到第三个分支，随后看第一个关键字【10&lt;12】故到第一个分支，随后看第一个关键字【10&lt;11】故到第一分支，由于第一分支是NULL，所以没有找到。</li>
</ul>
</blockquote>

<h3 id="toc_3">插入</h3>

<p>首先明确，对于一个阶为m的B-Tree：</p>

<ol>
<li>根节点的关键字容量为\(1\sim\left(m-1\right)\)；</li>
<li>中间节点和叶子节点的关键字容量为\(\left(\lceil\frac{m}{2}\rceil -1\right)\sim\left(m-1\right)\)。</li>
</ol>

<p>插入关键字可能会破坏B-Tree的规则(节点容量超过上限)，解决方法就是 &#39;&#39;拆分节点&#39;&#39;。</p>

<ul>
<li>Step 0：如果这是一颗空树，填入根节点的第一个关键字；</li>
<li>Step 1：搜索触底，插入的值应当是树中没有的(如果允许插入重复元素，要改一改判断语句)，所以最后会到达一个NULL的分支，根据规则此时一定会在叶子层(也就是最底层)；</li>
<li>Step 2：尝试把这个值作为关键字，和节点中的其他几个关键字排一下序，共同作为该节点新的关键字序列；</li>
<li>Step 3：看新关键字数量是否超过了节点容量上限：<br/>
** 如果没有超过，新的关键字序列存入该节点；<br/>
** 如果超过了，就取序列中间(如果有两个中间的就取一个)的一个关键字，两侧的关键字分裂为两个新的节点接在选出的关键字两侧。把这个选出的关键字插入上一层节点中(调回执行Step 2)——如果之前的节点是根节点就把该关键字作为新的根节点。</li>
</ul>

<blockquote>
<p>这是一个4阶B-Tree插入的例子，允许插入重复元素，动画来自 [[USFCA 数据结构可视化|<a href="https://www.cs.usfca.edu/%7Egalles/visualization/BTree.html%5D">https://www.cs.usfca.edu/~galles/visualization/BTree.html]</a>]<br/>
：</p>

<p><img src="media/15583364169947/201903171212166.gif" alt="201903171212166"/></p>
</blockquote>

<h3 id="toc_4">删除</h3>

<p>删除关键字可能会破坏B-Tree的规则(节点容量小于下限)，解决方法是：&#39;&#39;向其兄弟结点借关键字&#39;&#39;、&#39;&#39;与子结点进行关键字交换&#39;&#39;或&#39;&#39;进行结点的合并&#39;&#39;。其中，和当前结点的孩子进行关键字交换的操作可以保证删除操作总是发生在终端结点上。网上所总结的调整方法过于复杂，这里使用一种简洁统一的方法：</p>

<ul>
<li>Step 0：如果这是一颗空树，或者没有找到要删除的值，返回。</li>
<li>Step 1：删除节点(递归向下)
<ul>
<li>如果要删除的值在叶子节点，那么先直接删除：</li>
<li>如果要删除的值在非叶子节点，那么：
<ul>
<li>如果该点左侧和右侧的分支，都没有达到最小容量下限，就拿左侧最大关键字或者右侧最小关键字(Y)来替换它(X)，然后再递归删除那一个最值关键字(Y)；</li>
<li>如果该点左侧已达到下限而右侧没有，就用右侧最小替换然后递归删除；</li>
<li>如果该点右侧已达到下限而左侧没有，同理；</li>
<li>如果该点左右两侧分支都达到最小下限，就直接删除该关键字，并将右侧分支合并入左侧分支变成一个分支。</li>
</ul></li>
</ul></li>
<li>Step 3：调整节点
<ul>
<li>如果删除之后该点的关键字数量不少于容量下限，不用作调整，完成删除。</li>
<li>如果删除之后该点的关键字数量少于容量下限：
<ul>
<li>如果其右侧和左侧的兄弟节点的关键字数量都大于容量下限，取左侧兄弟节点与该节点之间的父节点关键字放入该节点，再取左侧兄弟节点的最大关键字替换父节点的关键字 &#39;&#39;(左旋)&#39;&#39; ，然后递归到删除左侧兄弟节点最大关键字；或者取右侧兄弟节点与该节点之间的父节点关键字放入该节点，再取右侧兄弟节点的最小关键字替换父节点的关键字 &#39;&#39;(右旋)&#39;&#39; ，然后递归到删除右侧兄弟节点最小关键字；</li>
<li>如果其左侧兄弟节点的关键字数量大于容量下限，而右侧兄弟节点的关键字数量等于容量下限，那么只能用左边来做；</li>
<li>如果其右侧兄弟节点的关键字数量大于容量下限，而左侧兄弟节点的关键字数量等于容量下限，反之；</li>
<li>如果两侧兄弟节点的关键字数量都等于容量下限，那么把左侧节点的关键字、左侧和该节点之间父节点的关键字和该节点剩余的关键字合并到一起成为新的左侧兄弟节点，删除父节点对应关键字和该节点；或者拿右侧做(同理)；</li>
</ul></li>
</ul></li>
<li>Step 4：递归向上，继续第三步调整</li>
</ul>

<p>这里有一个<a href="https://www.jb51.net/article/154166.htm">删除的例子</a>。</p>
<br/>
<p>以上算法的复杂度均为\(O\left(\log_{M-1}{N}\right)\sim O\left(\log_{M/2}{N}\right)\)。</p>

<p>这种效率是很高的，对于N=6.2×10<sup>10</sup> 个节点，如果度为1024，则只需要小于4次即可定位到该节点，然后再采用二分查找即可找到要找的值。</p>

<hr/>

<h2 id="toc_5">参考</h2>

<ul>
<li><a href="https://www.jianshu.com/p/7dedb7ebe033">https://www.jianshu.com/p/7dedb7ebe033</a></li>
<li><a href="http://www.cnblogs.com/vincently/p/4526560.html">http://www.cnblogs.com/vincently/p/4526560.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态查找树]]></title>
    <link href="https://gk0wk.github.io/15583362803987.html"/>
    <updated>2019-05-20T15:11:20+08:00</updated>
    <id>https://gk0wk.github.io/15583362803987.html</id>
    <content type="html"><![CDATA[
<p>树是一种可用的查找结构。有很多种规则来构造一颗查找树。这其中，具有动态结构(增减节点时无需彻底重建树)的一类树叫做动态查找树。</p>

<p>一般来讲，动态查找树的查找的复杂度在\(O\left(\log{N}\right)\)，最坏可以达到\(O\left(N\right)\)。一些结构在较差情况下复杂度增加较快(比如二叉查找树。</p>

<span id="more"></span><!-- more -->

<hr/>

<ul>
<li>二叉查找树(Binary Search Tree)是实现方式简单的二叉查找结构，插入和删除比较容易，缺点就是容易失衡(比如树开始变得很偏甚至直接变成线性的，定义见下)而且失衡的时候查找复杂度很糟。</li>
</ul>

<p>在BST的基础上，为了一定程度上避免树结构失衡时对查找复杂度的影响，提出<code>平衡树(Balanced Tree)</code>的概念：</p>

<blockquote>
<p>平衡树是计算机科学中的一类改进的二叉查找树。一般的二叉查找树的查询复杂度是跟目标结点到树根的距离（即深度）有关，因此当结点的深度普遍较大时，查询的 [[摊还复杂度|摊还复杂度分析(Amortized Analysis)]] 会上升，为了更高效的查询，平衡树应运而生了。</p>

<p>定义平衡：指所有叶子的深度趋于平衡，&#39;&#39;更广义的是指在树上所有可能查找的摊还复杂度偏低&#39;&#39;。</p>

<p>也可以用<code>平均查找时间(Average Search Time)</code>来衡量一颗查找树的查找性能，和摊还复杂度不同（摊还复杂度涉及每个节点查找的概率，而平均查找时间中每个节点被查找的概率是均等的）：</p>

<p>\[\overline{T}=\frac{1}{N}\underset{i=1}{\overset{N}{\sum}}h(V_i)\]</p>
</blockquote>

<p>常见平衡树有：</p>

<ul>
<li>平衡二叉查找树(AVL Tree)，经典平衡树, 所有操作的最坏复杂度都是 \(O\left(\log{N}\right) \)的。</li>
<li>Treap，利用随机堆的期望深度来优化树的深度，达到较优的期望复杂度。</li>
<li>伸展树(Splay Tree)，使得经常查找的结点深度较小，从而降低均摊复杂度。</li>
<li>红黑树(Red-Black Trees)：在AVL树的基础上做出优化和妥协，一种高效的搜索树。</li>
<li>加权平衡树。</li>
<li>2-3树、2-3-4树：分别是度为2和度为3的B-tree|多路搜索树(B-Tree)的特例</li>
<li>AA树</li>
<li>替罪羊树</li>
<li>节点大小平衡树</li>
</ul>

<hr/>

<p>以上查找树都是二叉树，但是在实际的大规模索引(如文件系统的索引、数据库等)中，以2为底的指数增长速度还不够快，导致二叉树存储大量数据时往往变得很深：</p>

<blockquote>
<p>因为索引的加载不可能一次全部加载进内存，磁盘读取每次读取的长度为一个磁盘页的长度，所以数据库系统会将一个节点的大小设为等于一页，这样保证了数据库每个节点只需要一次 IO 就可以完全加载。</p>

<p>每次新建节点，直接申请一个页的空间，计算机存储分配是按页对齐的，这样在物理上也保证了一个节点对应一页，保证一个节点只需要一次 IO。</p>
</blockquote>

<p>使用二叉查找树结构，由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下。所以需要采用多叉树结构来降低树的高度。常见的多叉查找树有：</p>

<ul>
<li><a href="15583364169947.html">多路搜索树(B-Tree)</a></li>
<li><a href="15583370060570.html">B+树(B+ Tree)</a>：B-Tree的变种。</li>
<li><a href="15583369413094.html">B*树(B* Tree)</a>：B+ Tree的变种。</li>
</ul>

<hr/>

<p>对于字符串的查找(如字典软件)，有专门的算法：</p>

<ul>
<li>Trie Tree</li>
<li>KMP</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[摊还复杂度分析(Amortized Analysis)]]></title>
    <link href="https://gk0wk.github.io/15583358377429.html"/>
    <updated>2019-05-20T15:03:57+08:00</updated>
    <id>https://gk0wk.github.io/15583358377429.html</id>
    <content type="html"><![CDATA[
<p>适用情况：一系列操作中，存在有个别到若干的最坏情况，每一个操作的耗时有一定的概率。这个操作序列中也许某一操作的代价很高，但因为还有其他操作，__所以这些操作的平均代价并没有那么高__。 </p>

<span id="more"></span><!-- more -->

<ul>
<li>“摊还”与“平均”： <u><strong>摊还分析不涉及概率</strong></u> ，但是涉及了连续操作之间的关联性，所以和单纯的“平均情况时间复杂度”不一样。&#39;&#39;摊还分析针对的是一系列操作的平均值，平均情况时间复杂度针对的是某种概率分布下不同输入的平均值。&#39;&#39;</li>
<li>“摊还”与“最坏”：这样的评价方式相比于最坏情况复杂度要更接近于实际情况，因为这个 “代价较高的操作” 往往不会经常发生。</li>
</ul>

<p>所以三者之间的关系通常为：<code>最坏情况时限(worst-case bound)</code> ≥ <code>摊还时限(amortized bound)</code> ≥ <code>平均情况时限(average-case bound)</code></p>

<hr/>

<p>我们通过一个例子来介绍三种摊还分析方法：</p>

<blockquote>
<h3 id="toc_0">例 1</h3>

<p>在一个栈中，有<code>Pop()</code>、<code>Push(x)</code>两种原子操作，定义其时间开支分别为1。</p>

<p>定义一个新的操作<code>MultiPop(k)</code>，连续推出k个元素(如果k≥n，就推出n个)，其C语言实现大致如下：</p>

<pre><code class="language-cpp">void MultiPop(int k, Stack S)
{
    while (!IsEmpty(S) &amp;&amp; k &gt; 0) {
        Pop(S);
        k--;
    } /* end while-loop */
}
</code></pre>

<p>试分析栈上数据操作的时间复杂度。</p>
</blockquote>

<h2 id="toc_1">累计分析/聚合分析(Aggregate Analysis)</h2>

<p>累计分析：<strong>直接 <u>考虑从空开始连续执行n次操作</u> (各种操作)的最坏情况的总时间 T(n) ，那么摊还时间就是</strong> \(\frac{T(n)}{n}\)。但是注意这个n不一定取整个数据结构的规模N，而取决于最坏情况。</p>

<p>对例1，我们考虑最坏的总体情况：<code>Push</code>和<code>Pop</code>的复杂度都是\(O\left(1\right)\)，而<code>MultiPop</code>的复杂度取决于栈满空程度和弹出数量，是\(O\left(1\right)\sim O\left(N\right)\)都有可能的。在这样的情况下。如果执行n次，那么最坏的情况可能就是\(O\left(n\right)\sim O\left(nN\right)\)……</p>

<p>但是我们换一个角度来考虑，不是只看一次的栈作，而看n次一系列的栈操作。__首先我们需要保证这一系列操作是从一个空栈开始的__，然后我们来想最糟的情况，<code>MultiPop</code>只能把已经入栈的元素出栈，所以最坏情况就是“前n-1次 <code>Push()</code>，最后一次 <code>MultiPop(n-1)</code>”，其他情况都没有这个糟。这样下来，复杂度就确认为\(O\left(N\right)\),在这种情况下，我们计算出例1的摊还时间是：</p>

<p>\[T_{amortized}=O(n)/n=O(1).\]</p>

<p>为什么会这样？我们可以看到对于例1，在一系列连续的操作中，先前的操作会影响到后面的操作，同时这一系列操作是有序的而不是相互独立可调换顺序的。所以摊还分析的结果与平均分析是不同的。</p>

<ul>
<li><p>累计分析中，我们只是单纯地将最坏情况中所有的开支加起来，然后再除以数据规模，把其中的每一个操作都看作相同的。在接下来的两种方法中，我们可能会对不同的操作赋以不同的摊还时间。</p></li>
<li><p><strong>“起始情况是空栈”是一个十分重要的前提！</strong>没有这个前提则分析结果不成立。</p></li>
</ul>

<p>再来看一个例子：</p>

<blockquote>
<h3 id="toc_2">例 2</h3>

<p>用一个N长度数组<code>a[N]</code>来存储一个N位10进制数字，<code>a[k]</code>存储第k位。有一个<code>Increase()</code>函数让这个数增加1(如果个位出现进位就要继续进到下一位，以此类推)。</p>

<p>理论上来讲，一个<code>Increase()</code>的最糟复杂度为\(O\left(N\right)\)，这个情况出现在<code>999...9+1</code>的时候，这样算如果连续执行n次，那么最糟的总复杂度为\(O\left(nN\right)\)。但是考虑到连续n次不可能每次都让所有位变更，所以__从初始状态<code>000...0</code>出发__，连续执行n次的过程中，考虑每一位的变动次数都是可以计算的，所以总共的时间为：</p>

<p>\[T(n)=\sum_{i=0}^{N-1}\left(\lfloor\frac{n}{10^i}\rfloor\cdot O\left(1\right)\right)=O\left(n\right)\]</p>

<p>所以摊还时间为\(T_{amortized}=O(n)/n=O(1).\)</p>
</blockquote>

<h2 id="toc_3">核算法/会计法(Accounting Method)</h2>

<p>在记账的时候，会出现”支出大于收入“的盈亏情况。核算法对每个不同类型的操作分别考虑成本，通过一种“收支盈亏”的会计学方法来分析摊还复杂度：</p>

<ul>
<li>定义 &#39;&#39;实际成本(Actual Cost)&#39;&#39;\(c_i\) 是某一个操作真正的时间开销；</li>
<li>定义 &#39;&#39;摊还成本(Amortized Cost)&#39;&#39;\(\hat{c_i}\) 是我们为一个操作赋予的“开支”。</li>
<li>当一个操作的 摊还成本 超出 实际成本 时，差额存入 &#39;&#39;信用额度(Credit)&#39;&#39;中；当 摊还成本 小于 实际成本 时，就可以 &#39;&#39;偿还(Pay)&#39;&#39;信用额度，和信用卡一个道理，这个信用额度可以定义为：</li>
</ul>

<p>\[\sum_{i=1}^n\left(\hat{c_i}-c_i\right)\]</p>

<p>然后即可证明</p>

<p>\[T(n)=\sum_{i=1}^nc_i\le\sum_{i=1}^n\hat{c_i}=O\left(\dots\right)\]</p>

<blockquote>
<h3 id="toc_4">关于摊还成本\(\hat{c_i}\)的选取</h3>

<p>摊还成本的选取不是随意的，需要满足：</p>

<p>操作序列的总摊还代价给出了序列总真实代价的上界，即数据结构所关联的信用必须一直非负值(\(\sum\hat{c_i}\ge\sum{c_i}\))，否则证明就是无效的。(不觉得很像比较判别法求级数极限吗)</p>
</blockquote>

<p>举一个例子：餐厅餐盘，拿取1元放回1元、或者拿取2元放回0元。前者是实际成本，后者是摊还成本。在考虑丢盘子的情况下，后者之和大于前者。用这个来证明 例1：</p>

<ul>
<li>\(c_i\) <code>Push(x)</code>是1，<code>Pop()</code>是1，<code>MultiPop(k)</code>是 min{sizeof(S),k}；</li>
<li>\(\hat{c_i}\) <code>Push(x)</code>是2，<code>Pop()</code>是0，<code>MultiPop(k)</code>是0，因为先<code>Push</code>才能<code>Pop</code>，所以要求是满足的。</li>
</ul>

<p><u>从空栈算起</u> ，总的时间\(T(n)=\sum{c_i}\le\sum{\hat{c_i}}\)，而\(\sum{\hat{c_i}}\)最多是2n(n次<code>Push</code>)，所以</p>

<p>\[T_{amortized}=O(n)/n=O(1).\]</p>

<p>这种方法应用于例2：某一位进1的摊还成本是2，复位为0的成本是0，剩余过程同理。</p>

<h2 id="toc_5">势能法(Potential Method)</h2>

<p>势能法和核算法类似，可以理解为物理上的势能。__在全空的初始态下(为零势能面)__，定义势能函数\(\Phi\left(D_n\right)\)：</p>

<p>\[\Phi\left(D_n\right)=\sum_{i=1}^n\left(\hat{c_i}-c_i\right),\quad\Phi\left(D_0\right)=0\]</p>

<p>这样，核算法中的信用额度就可以写为</p>

<p>\[\hat{c_i}-c_i=\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right)\]</p>

<p>进一步的</p>

<p>\[O\left(\dots\right)=\sum_{i=1}^n\hat{c_i}=\sum_{i=1}^n\left(c_i+\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right)\right)\\ =\sum_{i=1}^nc_i+\Phi\left(D_n\right)-\Phi\left(D_0\right)\ge\sum_{i=1}^nc_i=T(n)\]</p>

<p>与核算法不同，势能应于整个数据结构而不是特定对象相关联，将势能释放即可用来支付未来操作的代价。</p>

<blockquote>
<h3 id="toc_6">势能函数\(\Phi\left(D_i\right)\)的选取</h3>

<p>要求就是：任何时刻势能函数是非负值。</p>

<p>我们可以取一个东西作为势能指标，如果没有思路可以思考一下：有什么指标，是一个操作会将其改变、同时会让另一些操作因此而增加工作量的？</p>

<p>不同的势函数会产生不同的摊还代价，在选择势函数时，可以做出一定的权衡：是否使用最佳势函数依赖于对时间界的要求。</p>
</blockquote>

<p>用来证明 例1：把势能函数定义为栈中元素的个数。\(\Phi\left(D_0\right)=0\)，同时\(\Phi\left(D_i\right)\ge 0\)。</p>

<ul>
<li><code>Push(x)</code>：\(\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right)=1\)，\(\hat{c_i}=c_i+\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right)=2.\)</li>
<li><code>Pop()</code>：\(\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right)=-1\)，\(\hat{c_i}=c_i+\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right)=0.\)</li>
<li><code>MultiPop(k)</code>：\(\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right)=-k\)，\(\hat{c_i}=c_i+\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right)=0.\)</li>
</ul>

<p>\[\therefore \sum_{i=1}^n\hat{c_i}=O\left(n\right)\ge\sum_{i=1}^nc_i\]</p>

<p>\[\therefore T_{amortized}=O(n)/n=O(1).\]</p>

<hr/>

<h2 id="toc_7">三种方法的比较</h2>

<ol>
<li><p>聚合分析是简单地通过理解来得出一系列操作所需要的总代价，并由此得出每个操作的平均代价。核算法则是通过“精妙地设计每个操作的摊还代价”，来获得整体的摊还代价。势能法则与核算法相似，只不过是从整体考虑。</p></li>
<li><p>从理解难度来讲，聚合分析&lt;核算法&lt;势能法；从经验要求度来说，聚合分析&gt;核算法&gt;势能法。</p>
<ol>
<li> 首先要掌握的是势能法（找到 “势能” 所对应的对象，再通过它来获得每个操作的摊还代价，最后得出 n 个操作的代价）；</li>
<li>在熟练之后，我们可以直接根据经验得到每个操作的摊还代价，也就掌握了核算法；</li>
<li>最后进一步熟练，我们就可以直接理解得到 n 个操作的代价了，也就是掌握了聚合分析。</li>
</ol></li>
</ol>

<hr/>

<h3 id="toc_8">引用</h3>

<ul>
<li><a href="https://blog.csdn.net/woolseyyy/article/details/51517446">https://blog.csdn.net/woolseyyy/article/details/51517446</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1.3 配置目录]]></title>
    <link href="https://gk0wk.github.io/15439771752022.html"/>
    <updated>2018-12-05T10:32:55+08:00</updated>
    <id>https://gk0wk.github.io/15439771752022.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2.1 TiddlyWiki使用教程]]></title>
    <link href="https://gk0wk.github.io/15438144922083.html"/>
    <updated>2018-12-03T13:21:32+08:00</updated>
    <id>https://gk0wk.github.io/15438144922083.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

]]></content>
  </entry>
  
</feed>
